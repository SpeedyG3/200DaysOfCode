1) Jump Game - medium
ok solution
class Solution {
    public boolean canJump(int[] nums) {
        int reachable = 0; //total index reachable => reachable index
        for(int index = 0; index < nums.length; index ++) {
            if(index > reachable) return false;
            reachable = Math.max(reachable, index + nums[index]);
        } 
        return true;
    }
}
//all three solutions are bad in some or the other way 
recursion, memo ,tab (dp)
class Solution {
    public boolean canJump(int[] nums) {
        if(nums.length == 1) return true;
        int n = nums.length;
        int dp[]=new int[n];
        Arrays.fill(dp,-1);
        return solve(nums,0,n,dp);
    }
    public boolean solve(int[] a,int i,int n,int[] dp){
        if(i == n-1) return true;
        if(i >= n || a[i] == 0) return false;

        if(dp[i] != -1) return dp[i] == 0 ? false: true;

        boolean res = false;
        for(int j=1; j<= a[i]; j++){
            boolean small = solve(a,i+j,n,dp);
            res = res || small;
        }
        
        dp[i] = res ? 1 : 0;
        return res;
    }
}

better soln -> memoisation / dyn prog pls try
//but all three approaches give bad times for lc 