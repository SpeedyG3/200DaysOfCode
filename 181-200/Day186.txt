1) 51. N-Queens - hard
class Solution { //my cleanest solve
    public static void backtracking(int row, char board[][], List<List<String>> allBoards, int n){
        if(row==n){
            saveBoard(allBoards, board);
            return;
        }

        for(int col=0;col<n;col++){
            if(isSafe(board, row, col)){
                board[row][col] = 'Q';
                backtracking(row+1, board, allBoards, n);
                board[row][col] = '.';
            }
        }
    }

    public static boolean isSafe(char board[][], int row, int col){
        //checking col - wise
        for(int i=0;i<row;i++){
            if(board[i][col]=='Q'){
                return false;
            }
        }

        //only need to check left, right upward diagonals
        //no need to check for downward diagonals as we are filling from up - down 
        //and no Q exists down 
        
        //left - up diagonal 
        for(int i=row-1, j=col-1; i>=0 && j>=0; i--, j--){
            if(board[i][j]=='Q'){
                return false;
            }
        }

        //right - up diagonal
        for(int i=row-1, j=col+1; i>=0 && j<board.length; i--, j++){
            if(board[i][j]=='Q'){
                return false;
            }
        }
        return true;
    }

    public static void saveBoard(List<List<String>> allBoards, char board[][]){
        String row = "";
        List<String> newBoard = new ArrayList<>();
        for(int i=0;i<board.length;i++){
            row = "";
            for(int j=0;j<board[0].length;j++){
                if(board[i][j]=='Q'){
                    row+='Q';
                }else{
                    row+='.';
                }
            }
            newBoard.add(row);
        }
        allBoards.add(newBoard);
    }

    public List<List<String>> solveNQueens(int n) {
        List<List<String>> allBoards = new ArrayList<>();
        char board[][] = new char[n][n];
                    //row                       //can also do column based - similar 
        backtracking(0, board, allBoards, n);
        return allBoards;
    }
}

2) Rat in a maze - medium - GFG question - important backtracking/recursion
// a bit clean basic soln -> can make it cleaner

// m is the given matrix and n is the order of matrix
class Solution {
    public static void backtrack(int r, int c, String curr, ArrayList<String> allPaths, boolean vis[][], int m[][], int n){
        if(r==n-1 && c==n-1){
            allPaths.add(curr);
            return;
        }
        
        // D, L, R, U to get lexico sorted outputs
        //D => downward
        if(r+1<n && m[r+1][c]!=0 && !vis[r+1][c]){
            vis[r][c] = true;
            backtrack(r+1, c, curr+'D', allPaths, vis, m, n);
            vis[r][c] = false;
        }
        
        //L=> leftward
        if(c-1>=0 && m[r][c-1]!=0 && !vis[r][c-1]){
            vis[r][c] = true;
            backtrack(r, c-1, curr+'L', allPaths, vis, m, n);
            vis[r][c] = false;
        }
        
        //R=> rightward
        if(c+1<n && m[r][c+1]!=0 && !vis[r][c+1]){
            vis[r][c] = true;
            backtrack(r, c+1, curr+'R', allPaths, vis, m, n);
            vis[r][c] = false;
        }
        
        //U=> upward
        if(r-1>=0 && m[r-1][c]!=0 && !vis[r-1][c]){
            vis[r][c] = true;
            backtrack(r-1, c, curr+'U', allPaths, vis, m, n);
            vis[r][c] = false;
        }
    }
    
    public static ArrayList<String> findPath(int[][] m, int n) {
        // Your code here
        boolean vis[][] = new boolean[n][n];
        ArrayList<String> allPaths = new ArrayList<>();
        if(m[0][0]==1){
            backtrack(0, 0, "", allPaths, vis, m, n);    
        }
        return allPaths;
    }
}


//very clean code to make it minimal 
//minimalist soln 
class Solution {
    public static void backtrack(int r, int c, String curr, ArrayList<String> allPaths, boolean vis[][], 
    int m[][], int n, int di[], int dj[]){
        if(r==n-1 && c==n-1){
            allPaths.add(curr);
            return;
        }
        
        // D, L, R, U to get lexico sorted outputs
        String dir = "DLRU";
        for(int i=0;i<4;i++){
            int nexti = r+di[i];
            int nextj = c+dj[i];
            if(nexti>=0 && nextj>=0 && nexti<n && nextj<n && !vis[nexti][nextj] && m[nexti][nextj]==1){
                vis[r][c] = true;
                backtrack(nexti, nextj, curr+dir.charAt(i), allPaths, vis, m, n, di, dj);
                vis[r][c] = false;
            }
        }
    }
    
    public static ArrayList<String> findPath(int[][] m, int n) {
        // Your code here
        boolean vis[][] = new boolean[n][n];
        ArrayList<String> allPaths = new ArrayList<>();
        int di[] = {1, 0, 0, -1}; //row moves
        int dj[] = {0, -1, 1, 0}; //col moves 
        if(m[0][0]==1){
            backtrack(0, 0, "", allPaths, vis, m, n, di, dj);    
        }
        return allPaths;
    }
}
